#==================================================================================================
# R:/ModflowBinary/P80headDiffProbabilities.R
#==================================================================================================
#==================================================================================================
# Beginning of P80 Head Difference evaluation for Probable Change in Stressed Acres
#
# Created by Kevin A. Rodberg - February 2019
#
# Purpose: Uses 2 matrices returned by P80headDifference.R,
#          inports csvfiles of wetland point locations, and probability calculation
#          data [zetaModels generated by ZetaCalcIntegrals.R].  
#          Creates cell by cell probability matrix of change in
#          wetland stress and calculates the probable change in acres
#          by wetland type (ridge or plain) from stressed to unstressed and
#          from unstressed to stressed.
#==================================================================================================
list.of.packages <-c( "data.table","devtools","utils","tcltk2","rModflow",
                      "future.apply","future","listenv",
                      "rasterVis","sp","maptools","rgeos","raster",
                      "ggplot2","RColorBrewer","tictoc","dplyr","polynom")

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if (!'githubinstall' %in% installed.packages()[,"Package"]){
  install.packages('githubinstall')
}
if(length(new.packages)) install.packages(new.packages)
library(devtools)
if ("rModflow" %in% new.packages) devtools::install_github("KevinRodberg/rModflow")
lapply(list.of.packages,require, character.only=TRUE)

options(warn=-1)
#--------------------------------------------------------------------------------------------------
# Provides GUI to choose model  
# - may not be needed any long in this code since its used in P80headDifference.R
#--------------------------------------------------------------------------------------------------
source ("//ad.sfwmd.gov/dfsroot/data/wsd/SUP/devel/source/R/ReusableFunctions/tclFuncs.R")
#source ("./ECFTX/tclFuncs.R")

plan(multiprocess)
ip=0
lowQuantile = 999
hiQuantile = -999
pltGrphs <- listenv(NULL)
probReturn <- listenv(NULL)

#==================================================================================================
tic('Process one layer')
#==================================================================================================

#--------------------------------------------------------------------------------------------------
#  Code provides option to not reread very large files
#  MFLay <- NULL is an easy way to force P80headDifference to start
#--------------------------------------------------------------------------------------------------
if (!exists('Layer1SIM2d') | !exists('MFLay')) {
  MFLay <- 1
  source ("//ad.sfwmd.gov/dfsroot/data/wsd/SUP/devel/source/R/ModflowBinary/P80headDifference.R")
} else { 
  if(!(utils::askYesNo(paste("Do you want to use layer ",MFLay, 
                             " from the previous binary heads data?"),
                       prompts = getOption("askYesNo", 
                                           gettext(c("Yes", "No", "Cancel")))))){
    if (MFLay == 1){ MFLay <- 3 } else { MFLay <-1 }
  source ("//ad.sfwmd.gov/dfsroot/data/wsd/SUP/devel/source/R/ModflowBinary/P80headDifference.R")
}
}
#==================================================================================================
tic('Create Differences from P80 Heads Layers')
#==================================================================================================
dataPath <- '//ad.sfwmd.gov/dfsroot/data/wsd/SUP/proj/CFWI_WetlandStress/Update2018'
#dataPath <- 'C:/Users/Kevin/Desktop/ECFTX'

#Hint: If I subtract from this diffrence I get Stressed Wetlands Recovering

DiffLay %<-% (qRC - qSIM) 

#DiffLay <- (qSIM - qRC) -1.5

#--------------------------------------------------------------------------------------------------
#   Calculate mean water level layers simultaneously
#--------------------------------------------------------------------------------------------------
avgRC %<-% future_apply (Layer1RC2d,MARGIN=c(1,2),FUN=mean,na.rm=T)
avgSIM %<-%future_apply (Layer1SIM2d,MARGIN=c(1,2),FUN=mean,na.rm=T)

#--------------------------------------------------------------------------------------------------
#   Calculate a mean difference water level layer
#--------------------------------------------------------------------------------------------------
HdDif <- avgRC-avgSIM

#==================================================================================================
# Fisnished Creating Differences from P80 Heads Layers
#==================================================================================================
toc()
#==================================================================================================
tic('GIS overhead')
#==================================================================================================
cat('Developing GIS data sets for raster plots \n')

#--------------------------------------------------------------------------------------------------
# NAD83 HARN StatePlane Florida East FIPS 0901 Feet
#--------------------------------------------------------------------------------------------------
HARNSP17ft  = CRS("+init=epsg:2881")
HARNUTM17Nm  = CRS("+init=epsg:3747")
latlongs = CRS("+proj=longlat +datum=WGS84")

#--------------------------------------------------------------------------------------------------
# Set up county boundry shapefile for overlay 
# on raster maps
#--------------------------------------------------------------------------------------------------
gClip <- function(shp, bb) {
  if (class(bb) == "matrix")
    b_poly <- as(extent(as.vector(t(bb))), "SpatialPolygons")
  else
    b_poly <- as(extent(bb), "SpatialPolygons")
  rgeos::gIntersection(shp, b_poly, byid = T)
}

WMDbnd.Path <- "//whqhpc01p/hpcc_shared/krodberg/NexRadTS"
WMDbnd.Shape <- "CntyBnds"

CFWIbnd.Path <-"//ad.sfwmd.gov/dfsroot/data/wsd/GIS/GISP_2012/DistrictAreaProj/CFWI/Data"
CFWIbnd.Shape <- "CFWI_Boundary"

physio.Path <-paste0("//ad.sfwmd.gov/dfsroot/data/wsd/GIS/GISP_2012/",
                     "References/FDEP/Richardson_Sept2012/PhysiograhicProvinces")
physio.shape <- "PHYSIOGRAPHIC_PROVINCES"

SomeLakes.Path <- paste0("//ad.sfwmd.gov/dfsroot/data/wsd/GIS/GISP_2012/DistrictAreaProj/",
                         "ECFT/Data/Waterbodies")
SomeLakes.shape <- "Lakecells_Dissolve"

WMDbnd %<-% rgdal::readOGR(dsn=WMDbnd.Path,layer=WMDbnd.Shape,verbose=FALSE)
CFWIbnd %<-% rgdal::readOGR(dsn=CFWIbnd.Path,layer=CFWIbnd.Shape,verbose=FALSE)
physiobnd %<-% rgdal::readOGR(dsn=physio.Path,layer=physio.shape,verbose=FALSE)
SomeLakes %<-% rgdal::readOGR(dsn=SomeLakes.Path,layer=SomeLakes.shape,verbose=FALSE)

WMDbnd <- sp::spTransform(WMDbnd,CRS=HARNSP17ft)
CFWIbnd <- sp::spTransform(CFWIbnd,CRS=HARNSP17ft)
physiobnd <- sp::spTransform(physiobnd,CRS=HARNSP17ft)
SomeLakes <- sp::spTransform(SomeLakes,CRS=HARNSP17ft)
#==================================================================================================
# Finished GIS overhead
#==================================================================================================
toc()
#==================================================================================================
tic('Develop rasters')
#==================================================================================================
#--------------------------------------------------------------------------------------------------
# calculate number of rows and columns
#--------------------------------------------------------------------------------------------------
res=MFmodel.Params[model,]$res
xmin=MFmodel.Params[model,]$xmin
ymin=MFmodel.Params[model,]$ymin
rasRows=MFmodel.Params[model,]$nrows
rasCols=MFmodel.Params[model,]$ncols
xmax=xmin+(res*rasCols)
ymax=ymin+(res*rasRows)

cellsize=c(res,res)
ras <- raster::raster(res=cellsize, xmn=xmin,xmx=xmax,ymn=ymin,ymx=ymax,crs=HARNSP17ft)
#--------------------------------------------------------------------------------------------------
# define raster and map extents using MFmodel data extents
#--------------------------------------------------------------------------------------------------
rasExt <- raster::extent(ras)
clpBnds2 <- gClip(WMDbnd, ras)

#--------------------------------------------------------------------------------------------------
# Create raster plot of the DiffMatrix
#   note: t() is used to transpose the array axis for plotting
#--------------------------------------------------------------------------------------------------
diffRas<-raster::raster(t(DiffLay[,]),rasExt[1:4], crs=HARNSP17ft)

diffRas <- raster::crop(diffRas, extent(buffer(CFWIbnd,width=10000)))
diffRas %<-% raster::mask(diffRas, CFWIbnd)

title = paste("Change in Head Layer ",MFLay,": \n",
              RCheadsFile, '\nminus\n',SIMheadsFile)

basePath <- paste0("//ad.sfwmd.gov/dfsroot/data/wsd/SUP/proj/",
                   "CFWI_WetlandStress/Update2018/Figures4StressAcres/")

filename = paste0('p80headDiffLay',MFLay,'.tif')
ip=ip+1
pltGrphs[[ip]] <- future({
  raster::writeRaster(diffRas, filename, format="GTiff", overwrite=TRUE)
})

lowQuantile = min(lowQuantile,quantile(DiffLay,probs=c(.03),na.rm=T),na.rm=T)
hiQuantile = max(hiQuantile,quantile(DiffLay,probs=c(.97),na.rm=T),na.rm=T)
my.at = c(quantile(DiffLay,probs=c(.00001),na.rm=T),
          -2.5,-2.0,-1.5,-1.25,-1.0,-.75,-.5,-.25,-.2,-.15,-.1,-.05,0.0,
          .05,.1,.15,.2,0.25,0.50,0.75,1.0,1.25,1.5,2.0,2.5,
          quantile(DiffLay,probs=c(.99999),na.rm=T))

Class1.Wetland.Info <- 
  read.csv(paste0(dataPath,"/Class 1 Wetland Info for Analysis ALLv1.csv"))
c1Wtl.pnts <-
  sp::SpatialPointsDataFrame(Class1.Wetland.Info[,11:12],Class1.Wetland.Info,
                         proj4string=latlongs)
c1Wtl.pnts <- sp::spTransform(c1Wtl.pnts,HARNSP17ft)

filename=paste0(basePath,"Lay",MFLay,"_P80HeadDifference.png")
WLTheme = rasterTheme(region = brewer.pal('BrBG', n = 9))
options(scipen=7)
myplot= (levelplot(diffRas,par.settings = WLTheme,at=my.at,main=title)+
           latticeExtra::layer(sp.points(c1Wtl.pnts, pch = 20,col = "black")) +
           latticeExtra::layer(sp.text(coordinates(c1Wtl.pnts),
                                       txt=c1Wtl.pnts$CFCA.EMT.ID,pos=1,cex=.5 )) +
           latticeExtra::layer(sp.polygons(clpBnds2, col='darkgray'))+
           latticeExtra::layer(sp.polygons(physiobnd, col='brown'))+
           latticeExtra::layer(sp.polygons(SomeLakes, col='gray'))+
           latticeExtra::layer(sp.polygons(CFWIbnd, col='red'))
)
trellis.device(device="png", filename=filename, width=4500,height=4500,
               units="px",res=300)
print(myplot)
dev.off()

#---
# Convert array layers to rasters
#---
qRCras %<-% raster::raster(t(qRC[,]),rasExt[1:4], crs=HARNSP17ft)
qSIMras %<-% raster::raster(t(qSIM[,]),rasExt[1:4], crs=HARNSP17ft)
RCras %<-% raster::raster(t(avgRC[,]),rasExt[1:4], crs=HARNSP17ft)
SIMras %<-% raster::raster(t(avgSIM[,]),rasExt[1:4], crs=HARNSP17ft)
HdDifras %<-% raster::raster(t(HdDif[,]),rasExt[1:4], crs=HARNSP17ft)

qRCras[qRCras > 900]<-NA
RCras[RCras > 900]<-NA
qSIMras[qSIMras> 900 ]<-NA
SIMras[SIMras> 900 ]<-NA

#---
#  Function to create maps as png and tif from rasters 
#---
plotTiffAndPng <- function(ras2Plot,rasName){
  ras2Plot[ras2Plot > 900] <- NA
  Rng = max(abs(quantile(ras2Plot,probs=c(.00001),na.rm=T)),
            abs(quantile(ras2Plot,probs=c(.99999),na.rm=T)))
  interval = Rng/10
  my.at = c(seq(-Rng,Rng,interval))
    filename = paste0(rasName,MFLay,'.tif')
  writeRaster(ras2Plot, paste0(basePath,filename), format="GTiff", overwrite=TRUE)
  filename = paste0(basePath,rasName,MFLay,'.png')
  title =paste0(rasName,MFLay)
  myplot= (levelplot(ras2Plot,par.settings = WLTheme,at=my.at, main = title)+
             latticeExtra::layer(sp.polygons(clpBnds2, col='darkgray'))+
             latticeExtra::layer(sp.polygons(physiobnd, col='brown'))+
             latticeExtra::layer(sp.polygons(SomeLakes, col='blue'))+
             latticeExtra::layer(sp.polygons(CFWIbnd, col='red')))
  trellis.device(device="png", filename=filename, width=3000,height=4500,units="px",res=300)
  print(myplot)
  dev.off()
}

ip=ip+1
pltGrphs[[ip]] <- future({plotTiffAndPng(HdDifras,'meanHeadDiffLay')})
ip=ip+1
pltGrphs[[ip]] <- future({plotTiffAndPng(SIMras,'meanSIMLay')})
ip=ip+1
pltGrphs[[ip]] <- future({plotTiffAndPng(RCras,'meanRCLay')})
ip=ip+1
pltGrphs[[ip]] <- future({plotTiffAndPng(qSIMras,'p80SIMLay')})
ip=ip+1
pltGrphs[[ip]] <- future({plotTiffAndPng(qRCras,'p80RCLay')})

#==================================================================================================
# Fisnished Developing rasters for GIS and map pngs
#==================================================================================================
toc()
#==================================================================================================
tic("Read Wetland datasets")
#==================================================================================================
#  Read Polynomial Coefficiencts for Zeta Calculations
#     and
#  wetlands points by class from GIS exports
#     and
#  eliminate unnecessary columns, rename fields for consistency, 
#  as well as fix Stressed column indicator to be consistent for 
#  Class 1 and 2
#====================================================================
# polys<-read.csv(paste0(dataPath,"/PolyCoeff2019.csv"))
SFact<-read.csv(paste0(dataPath,"/StressFactor.csv"))

#class1 %<-% read.csv(paste0(dataPath,"/WetlandsClass1_2018.csv"))
class1 %<-% read.csv(paste0(dataPath,"/WetlandsClass1_2019.csv"))
#class2 %<-% read.csv(paste0(dataPath,"/WetlandsClass2_2018.csv"))
class2 %<-% read.csv(paste0(dataPath,"/WetlandsClass2_2019.csv"))
#class3 %<-% read.csv(paste0(dataPath,"/WetlandsClass3_2018.csv"))
class3 %<-% read.csv(paste0(dataPath,"/WetlandsClass3_2019v2.csv"))

class1<- merge(x=class1, 
               y=Class1.Wetland.Info[,c('CFCA.EMT.ID','Stress.Status.in.2018')],
               by.x = "CFCA_EMT_I", by.y = 'CFCA.EMT.ID')

#NotNeeded <- c("OBJECTID","CFCA_EMT_1","PERCENT_AC","Shape_Length","Shape_Area")
NotNeeded <- c("OBJECTID")
class1[NotNeeded]<-NULL
setnames(class1, "CFCA_EMT_I", "CFCA_EMT_ID")
setnames(class1, "Wetland_Ty", "Wetland_Type")
setnames(class1, "Physiograp", "Phys")
setnames(class1, "Stress.Status.in.2018", "Stressed")
setnames(class1, "ACRES_COMB", "Acres")

levels(class1$Stressed)[which(levels(class1$Stressed)=="Not Stressed")] <- "NO"
levels(class1$Stressed)[which(levels(class1$Stressed)=="Stressed")] <- "YES"

Needed <- c("CFCA_ID","ACRES_COMB","Ridge_or_Plains","SEQNUM","XCOORD_UTM" ,"YCOORD_UTM" ,"Stressed")

class2 <- class2[,Needed]
setnames(class2, "CFCA_ID", "CFCA_EMT_ID")
setnames(class2, "ACRES_COMB", "Acres")
setnames(class2, "Ridge_or_Plains", "Phys")

levels(class2$Phys)[which(levels(class2$Phys)=="Plains")] <- "Plain"

Needed<-c("SEQNUM","Hydroclass","EcoHydro_T","Wetland_Ty","Urban_Dens","SusceptGW",   
          "Class","XCOORD_UTM","YCOORD_UTM","ACRES_COMB")

class3 <- class3[,Needed]
setnames(class3, "ACRES_COMB", "Acres")
setnames(class3, "Wetland_Ty", "Phys")
setnames(class3, "Urban_Dens", "Urban_Density")


vars4AreaZ <- c("Zus","Zsu")
class1[vars4AreaZ]<- NA
class2[vars4AreaZ]<- NA
class3[vars4AreaZ]<- NA

vars4SF <- c("SFsu","SFus")
class1[vars4SF]<-1.0
class2[vars4SF]<-1.0
class3[vars4SF]<-NA

#---------------------------------------------------------------------------------
# Wetland Weighting Factors:
# The reason for the weighting factors is that the Class 1 & Class 2 wetlands have
# been physically inspected. 
#
# 1. Wetlands that are of the wrong hydrobiologic type have been excluded 
# 2. "Significantly Hydrologically Altered" (SHA) Wetlands have been excluded 
# 3. Wetland condition is known to be either stressed or unstressed.
# 
# Without physical inspections of the Class 3 wetlands to supply that information,
# the total GIS wetland area is assigned a probability factor to represent the 
# likelihood of the wetland being one for which either the Zu-s or Zs-u equation is 
# appropriate.  
#
# These probability factors were derived by comparing the Class 2 wetlands to the 
# corresponding total wetland coverages.  
#
# First multiply by the Dissimilarity Factor and the SHA Factor - 
#     this reduces the total acreage by an amount that corrects for the likelihood 
#     of GIS wetland area that is the "wrong" type of wetland, or that is SHA.  
#
# Second Multiply that product again - 
# once by the fraction of the surviving wetlands that are initially unstressed 
#   to produce the SFu-s total correction factor, 
#     and once by the fraction of the surviving wetlands that are initially  
#       stressed to produce the SFs-u total correction factor.
#
#     TotCorrFact_us = DisFac*SHA_Fact*SFus
#     TotCorrFact_su = DisFac*SHA_Fact*SFsu
#---------------------------------------------------------------------------------
#  Wetland 	Urban 	Dissimilar 	SHA 	   Stress   Stress  Correction  Correction 
#  Type     Density   Factor    Factor   Factor   Factor    Factor       Factor
#                                       (u to s) (s to u)    (u-s)        (s-u)
#---------------------------------------------------------------------------------
#  Plain     low      0.694     0.820      0.824    0.176    0.469        0.100
#  Plain  Mod & High  0.616     0.581      0.824    0.176    0.295        0.063
#  Ridge     All      0.671     1.000      0.581    0.419    0.390        0.281
#---------------------------------------------------------------------------------
class3[class3$Phys=='Plain',]$SFus = SFact[SFact$Wetland.Type=='Plain' & SFact$Urban.Density == 'low',]$Sfus
class3[class3$Phys=='Plain',]$SFsu = SFact[SFact$Wetland.Type=='Plain' & SFact$Urban.Density == 'low',]$Sfsu

class3[class3$Phys=='Plain' &  (class3$Urban_Density=='Moderate' | class3$Urban_Density=='High') ,]$SFus =
  SFact[SFact$Wetland.Type=='Plain' & SFact$Urban.Density == 'Mod & High',]$Sfus
class3[class3$Phys=='Plain' &  (class3$Urban_Density=='Moderate' | class3$Urban_Density=='High') ,]$SFsu = 
  SFact[SFact$Wetland.Type=='Plain' & SFact$Urban.Density == 'Mod & High',]$Sfsu

class3[class3$Phys=='Ridge',]$SFus = SFact[SFact$Wetland.Type=='Ridge',]$Sfus
class3[class3$Phys=='Ridge',]$SFsu = SFact[SFact$Wetland.Type=='Ridge',]$Sfsu
#==================================================================================================
# Finished Reading Wetland datasets
#==================================================================================================
toc()
#==================================================================================================
tic('Calculate probable stress for wetlands')
#==================================================================================================
#--------------------------------------------------------------------------------------------------
#  Create template dataframe for Stats
#--------------------------------------------------------------------------------------------------
if (!exists('Stats')){
  Layer <- c(rep(1,12),rep(3,12))
  Class<- rep(c(1,1,2,2,3,3,1,1,2,2,3,3),2)
  Stress<-rep(c(rep('Stressed',6),rep('Unstressed',6)),2)
  Phys<-rep(c('Ridge','Plain'),12)
  Stats<-data.frame(Layer,Class,Stress,Phys,stringsAsFactors=FALSE)
  statColumns<-c('Initial','Delta')
  Stats[statColumns]<-NA
}

WetType = c("Plain" ,"Ridge")

WetCond<-c('YES', 'NO')
ZetaCond<-c('Stressed', 'Unstressed')

#--------------------------------------------------------------------------------------------------
#  Read zeta Models created by ZetaCalcIntegrals.R rather than polyCoeff.csv 
#--------------------------------------------------------------------------------------------------
#workdir= "Y:/proj/CFWI_WetlandStress/Update2018"
workdir= "//ad.sfwmd.gov/dfsroot/data/wsd/SUP/proj/CFWI_WetlandStress/Update2018"
zetaModels=readRDS( paste0(workdir,"zetaModels.RDS"))

#--------------------------------------------------------------------------------------------------
#  Function to create probLay matrix of probabilities 
#--------------------------------------------------------------------------------------------------
getProbLay<- function(DiffLay,NegModel,PosModel){
  probLay<-DiffLay
  newdata <- data.frame (delta = as.vector(DiffLay[DiffLay<0]))
  probtemp<- predict(NegModel,newdata=newdata)
  probLay[DiffLay<0]<-probtemp
  newdata <- data.frame (delta = as.vector(probLay[DiffLay>=0]))
  probtemp<- predict(PosModel,newdata=newdata)
  probLay[DiffLay>=0]<-probtemp
  return(probLay)
}
ip=0
ipl=0
for (c in ZetaCond){
  p<- NULL
  probLay<- (DiffLay*0)
  for (t in WetType) {
    cc = 'NO'
    zetaName = 'us'
    probTitle <- 'Unstressed to Stressed'
    if(c == 'Stressed'){
      cc = 'YES'
      zetaName = 'su'
      probTitle <- 'Stressed to Unstressed'
      }
    ipl=ipl+1
    if (t == 'Ridge' & c == 'Unstressed'){
      probLay<-getProbLay(DiffLay,zetaModels$ZRPu_sNeg,zetaModels$ZRPu_sPos)
    } else if (t == 'Ridge' & c == 'Stressed'){
      probLay<-getProbLay(DiffLay,zetaModels$ZRPs_uNeg,zetaModels$ZRPs_uPos)
    } else if (t == 'Plain' & c == 'Unstressed'){
      probLay<-getProbLay(DiffLay,zetaModels$ZPPu_sNeg,zetaModels$ZPPu_sPos)
    }else if (t == 'Plain' & c == 'Stressed'){
      probLay<-getProbLay(DiffLay,zetaModels$ZPPs_uNeg,zetaModels$ZPPs_uPos)
    } else {
      cat('Something goofed up!\n')
      cat(paste(c, t))
    }
    probLay[probLay<0] <- 0
    probLay[probLay>1] <- 1
    #--------------------------------------------------------------------------
    #  probLay matrix of probabilities is intersected w/wetlands pnts by SEQNUM
    #--------------------------------------------------------------------------
    zetaCol <-match(paste0('Z',zetaName),names(class1))
    class1[class1$Phys == t & class1$Stressed ==cc,zetaCol] <-
      round(probLay[class1[class1$Phys == t & class1$Stressed ==cc,]$SEQNUM],8)
    
    zetaCol <-match(paste0('Z',zetaName),names(class2))
    class2[class2$Phys == t & class2$Stressed ==cc,zetaCol] <-
      round(probLay[class2[class2$Phys == t & class2$Stressed ==cc,]$SEQNUM],8)
    
    # Initial stress condition is not know for class 3
    zetaCol <-match(paste0('Z',zetaName),names(class3))
    class3[class3$Phys == t,zetaCol] <-
      round(probLay[class3[class3$Phys == t,]$SEQNUM],8)
    #--------------------------------------------------------------------------
    # Crop raster data by extent of CFWI bndry
    #--------------------------------------------------------------------------
    
    probRas<-raster::raster(t(probLay[,]),rasExt[1:4], crs=HARNSP17ft)    
    yourTheme = rasterTheme(region = brewer.pal('YlOrRd', n = 9))
    CFWIprobs <- raster::crop(probRas, extent(buffer(CFWIbnd,width=10000)))
    CFWIprobs <- raster::mask(CFWIprobs, CFWIbnd)
    ip=ip+1
    pltGrphs[[ip]] <- future({
      plotTiffAndPng(CFWIprobs,paste('CFWIprob',t,probTitle)) 
    })
     
  }
}
#--------------------------------------------------------------------------
#  Class 1, 2, & 3 wetland probable change in area is calculated as
#   Stressed becoming unstressed:
#     AreaXZsu = Acres * SFsu * probs
#
#   Unstressed becoming stressed:
#     AreaXZus = Acres * SFus * probs
#--------------------------------------------------------------------------
class1 <- class1 %>% mutate(AreaXZsu = Acres*SFsu*Zsu)
class1 <- class1 %>% mutate(AreaXZus = Acres*SFus*Zus)

class2 <- class2 %>% mutate(AreaXZsu = Acres*SFsu*Zsu)
class2 <- class2 %>% mutate(AreaXZus = Acres*SFus*Zus)

class3 <- class3 %>% mutate(AreaXZsu = Acres*SFsu*Zsu)
class3 <- class3 %>% mutate(AreaXZus = Acres*SFus*Zus)
#==================================================================================================
# Fisnised Calculating probable stress for wetlands
#==================================================================================================
toc()
#==================================================================================================
tic("Creating maps")
#==================================================================================================
class1.pnts <- sp::SpatialPointsDataFrame(coords = class1[, c("XCOORD_UTM", "YCOORD_UTM")], 
                                           data = class1,proj4string = HARNUTM17Nm)
c1.pnts<-sp::spTransform(class1.pnts,HARNSP17ft)

class2.pnts <- sp::SpatialPointsDataFrame(coords = class2[, c("XCOORD_UTM", "YCOORD_UTM")], 
                                          data = class2,proj4string = HARNUTM17Nm)
c2.pnts<-sp::spTransform(class2.pnts,HARNSP17ft)

class3.pnts <-sp::SpatialPointsDataFrame(coords = class3[, c("XCOORD_UTM", "YCOORD_UTM")],
                                         data = class3,proj4string = HARNUTM17Nm)
c3.pnts<-sp::spTransform(class3.pnts,HARNSP17ft)

probRas<-raster::raster(t(probLay[,]),rasExt[1:4], crs=HARNSP17ft)
yourTheme = rasterTheme(region = brewer.pal('YlOrRd', n = 9))

#--------------------------------------------------------------------------
# Crop raster data by extent of CFWI bndry
#--------------------------------------------------------------------------
CFWIprobs <- raster::crop(probRas, extent(buffer(CFWIbnd,width=10000)))
CFWIprobs <- raster::mask(CFWIprobs, CFWIbnd)

updateStatsDelta<- function(Stats,MFLay,t,c,class,source) {
  # cat(paste(Stats[Stats$Layer == MFLay & 
  #                   Stats$Phys ==t & 
  #                   Stats$Stress ==c & 
  #                   Stats$Class==class,]$Delta,
  #           MFLay,t,c,class,sum(source,na.rm=T),'\n'))
  Stats[Stats$Layer == MFLay & 
          Stats$Phys ==t & 
          Stats$Stress ==c & 
          Stats$Class==class,]$Delta <- round(sum(source,na.rm=T),2)
  return(Stats)
}
updateStatsInitial<- function(Stats,MFLay,t,c,class,Acres) {
  # cat(paste(Stats[Stats$Layer == MFLay & 
  #                   Stats$Phys ==t & 
  #                   Stats$Stress ==c & 
  #                   Stats$Class==class,]$Initial,
  #           MFLay,t,c,class,sum(Acres,na.rm=T),'\n'))
  Stats[Stats$Layer == MFLay & 
          Stats$Phys ==t & 
          Stats$Stress ==c & 
          Stats$Class==class,]$Initial <- round(sum(Acres,na.rm=T),2)
  return(Stats)
}

ip=0
deltas = stack()
for (t in WetType) {
  ttlWetAcres = 0
  for (c in ZetaCond){
    if (c == 'Stressed') {
      cc <-'YES'
      c1sub <-c1.pnts[c1.pnts$Phys==t & c1.pnts$Stressed==cc,c('Phys','AreaXZsu')]
      c2sub <-c2.pnts[c2.pnts$Phys==t & c2.pnts$Stressed==cc,c('Phys','AreaXZsu')]
      c3sub <-c3.pnts[c3.pnts$Phys==t ,c('Phys','AreaXZsu')]
      c123sub<-rbind(c1sub,c2sub)
      c123sub<-rbind(c123sub,c3sub)
      Stats<-updateStatsDelta(Stats,MFLay,t,c,1,c1sub$AreaXZsu)
      Stats<-updateStatsDelta(Stats,MFLay,t,c,2,c2sub$AreaXZsu)
      Stats<-updateStatsDelta(Stats,MFLay,t,c,3,c3sub$AreaXZsu)

      Acres =   c1.pnts[c1.pnts$Phys ==t & c1.pnts$Stressed ==cc ,]$Acres
      Stats<-updateStatsInitial(Stats,MFLay,t,c,1,Acres)
      Acres =   c2.pnts[c2.pnts$Phys ==t & c2.pnts$Stressed ==cc ,]$Acres
      Stats<-updateStatsInitial(Stats,MFLay,t,c,2,Acres)
      Acres =  c3.pnts[c3.pnts$Phys ==t,]$Acres * c3.pnts[c3.pnts$Phys ==t,]$SFsu
      Stats<-updateStatsInitial(Stats,MFLay,t,c,3,Acres)
      
    } else {
      cc<-'NO'
      c1sub <-c1.pnts[c1.pnts$Phys==t & c1.pnts$Stressed==cc,c('Phys','AreaXZus')]
      c2sub <-c2.pnts[c2.pnts$Phys==t & c2.pnts$Stressed==cc,c('Phys','AreaXZus')]
      c3sub <-c3.pnts[c3.pnts$Phys==t,c('Phys','AreaXZus')]
      
      c123sub<-rbind(c1sub,c2sub)
      c123sub<-rbind(c123sub,c3sub)
      
      Stats<-updateStatsDelta(Stats,MFLay,t,c,1,c1sub$AreaXZus)
      Stats<-updateStatsDelta(Stats,MFLay,t,c,2,c2sub$AreaXZus)
      Stats<-updateStatsDelta(Stats,MFLay,t,c,3,c3sub$AreaXZus)

      Acres =   c1.pnts[c1.pnts$Phys ==t & c1.pnts$Stressed ==cc ,]$Acres
      Stats<-updateStatsInitial(Stats,MFLay,t,c,1,Acres)
      Acres =   c2.pnts[c2.pnts$Phys ==t & c2.pnts$Stressed ==cc ,]$Acres
      Stats<-updateStatsInitial(Stats,MFLay,t,c,2,Acres)
      Acres =  c3.pnts[c3.pnts$Phys ==t,]$Acres * c3.pnts[c3.pnts$Phys ==t,]$SFus
      Stats<-updateStatsInitial(Stats,MFLay,t,c,3,Acres)
    }   
    if (MFLay == 3){
      Stats[Stats$Layer == 3 & Stats$Phys =='Plain' ,]$Delta<- 0
      Stats[Stats$Layer == 3 & Stats$Phys =='Plain' ,]$Initial<- 0
    }
    c1.delta<-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==1,]$Delta
    c2.delta<-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==2,]$Delta
    c3.delta<-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==3,]$Delta
    
    c1.initial <-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==1,]$Initial
    c2.initial <-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==2,]$Initial
    c3.initial <-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==3,]$Initial
    
    tabStats = paste('c1=',round(c1.delta,2),'c2=',round(c2.delta,2),'c3=',round(c3.delta,2),'\n',
                     round(sum(c1.delta,c2.delta,c3.delta),2),'/',
                     round(sum(c1.initial,c2.initial,c3.initial),2),'=', 
                     round(100*sum(c1.delta,c2.delta,c3.delta)/
                             sum(c1.initial,c2.initial,c3.initial),2),'% of',t,'Wetlands')
    if (c == ZetaCond[2]){
      title = paste0('Layer ',MFLay,' ',c,' ',t,' to ', ZetaCond[1], '\n',tabStats)
      filename=paste(basePath,paste0('Lay',MFLay,t,'-',c,'_to_',ZetaCond[1]),".png",sep="")
      acre.At = c(0,.5,1,2.5,5,7.5,10,max(c123sub$AreaXZus))
      deltaArea<- rasterize(c123sub,CFWIprobs,c123sub$AreaXZus)
      tiffilename=paste(basePath,paste0('Lay',MFLay,t,'-',c,'_to_',ZetaCond[1]),".tif",sep="")
    }else {
      title = paste0('Layer ',MFLay,' ',c,' ',t,' to ', ZetaCond[2], '\n',tabStats)
      filename=paste(basePath,paste0('Lay',MFLay,t,'-',c,'_to_',ZetaCond[2]),".png",sep="")
      acre.At = c(0,.5,1,2.5,5,7.5,10,max(c123sub$AreaXZsu,na.rm=TRUE))
      deltaArea<- rasterize(c123sub,CFWIprobs,c123sub$AreaXZsu)
      tiffilename=paste(basePath,paste0('Lay',MFLay,t,'-',c,'_to_',ZetaCond[2]),".tif",sep="")
    }
    
    deltaArea[deltaArea==0]<-NA
    
    if(!(MFLay ==3 & t == 'Plain')){
      if (cc=='NO'){
        yourTheme = rasterTheme(region = brewer.pal('YlOrRd', n = 9))
      } else {
        yourTheme = rasterTheme(region = brewer.pal('YlGn', n = 9))
        
      }
          
      ip=ip+1
      deltas <- stack(deltas,deltaArea)
      pltGrphs[[ip]] <- future({
      myplot= (levelplot(deltaArea,par.settings = yourTheme,at=acre.At, main = title)+
                 latticeExtra::layer(sp.polygons(clpBnds2, col='darkgray'))+
                 latticeExtra::layer(sp.polygons(physiobnd, col='brown'))+
                 latticeExtra::layer(sp.polygons(SomeLakes, col='blue'))+
                 latticeExtra::layer(sp.polygons(CFWIbnd, col='red')))
      trellis.device(device="png", filename=filename, width=3000,height=4500,units="px",res=300)
      print(myplot)
      dev.off()
      })
      ip=ip+1
      pltGrphs[[ip]] <- future({
        raster::writeRaster(deltaArea, tiffilename, format="GTiff", overwrite=TRUE)
      })
    }
  }
}
if (MFLay == 1){
  names(deltas)<- c('Plain_StoU','Plain_UtoS','Ridge_StoU','Ridge_UtoS')
  deltas$Plain_StoU <- deltas$Plain_StoU*(-1.0)
} else {
  names(deltas)<- c('Ridge_StoU','Ridge_UtoS')
}
deltas$Ridge_StoU <- deltas$Ridge_StoU*(-1.0)
index<-names(deltas)
FinalNetStress <- raster::stackApply(deltas,1,fun=base::sum,na.rm=TRUE)
tiffilename=paste0(basePath,paste0('Lay',MFLay,"_NetStress.tif",sep=""))
ip=ip+1

# extreme = max(abs(maxValue(FinalNetStress)), abs(minValue(FinalNetStress)))
filename=paste(basePath,paste0('Lay',MFLay,"_NetStress.png",sep=""))
title = paste0('Lay',MFLay,'_NetStress')
if (lowQuantile <0){
  ramp<-c(seq(lowQuantile, -.01, length=5), seq(0.01, hiQuantile, length=5))
  yourTheme = rasterTheme(region = c(colorRampPalette(c("seagreen", "white"))(5),
                                     colorRampPalette(c("white", "firebrick"))(5)))
}else {
  ramp<-seq(-1, hiQuantile, length=10)
  yourTheme = rasterTheme(region =colorRampPalette(c("white", "firebrick"))(11))
}
pltGrphs[[ip]] <- future({
  myplot= (levelplot(FinalNetStress,par.settings = yourTheme,at=ramp, main = title)+
             latticeExtra::layer(sp.polygons(clpBnds2, col='darkgray'))+
             latticeExtra::layer(sp.polygons(SomeLakes, col='blue'))+
             latticeExtra::layer(sp.polygons(CFWIbnd, col='red')))
  trellis.device(device="png", filename=filename, width=3000,height=4500,units="px",res=300)
  print(myplot)
  dev.off()
})
pltGrphs[[ip]] <- future({
  raster::writeRaster(FinalNetStress, tiffilename, format="GTiff", overwrite=TRUE)
})

toc()
#==================================================================================================
# Finished Creating maps
#==================================================================================================

write.csv(Stats,paste0(basePath,'WetlandStressStats.csv'))
#==================================================================================================
# Create Bar Charts from Wetland Stats
#==================================================================================================

colours <- c("red", "orange", "blue", "yellow", "green")
longStats<-melt(Stats,id.vars=1:4)
longStats<-within(longStats, Class <- factor(Class))

pieces<-unlist(strsplit(RCheadsFile,"[\\\\]|[^[:print:]]"))
RCtitle <- pieces[length(pieces)-1]
pieces<-unlist(strsplit(SIMheadsFile,"[\\\\]|[^[:print:]]"))
SIMtitle <- pieces[length(pieces)-1]
L = MFLay

ggplot(longStats[longStats$variable=='Delta' & longStats$Layer == L,], 
       aes(x = paste(Stress,Phys), y = value, 
           fill = Class)) +
  geom_bar(stat = 'identity') +
  xlab("Initial Condition") +
  ylab("Acres of Change") +
  ggtitle(paste0("Layer",L,'\n',RCtitle,' minus ',SIMtitle))
plotfile =paste0(basePath,'Lay',L,'Barchart.png')
ggsave(plotfile,width = 10,height = 7.5,units = "in",dpi = 300,device = "png")


#==================================================================================================
toc()

