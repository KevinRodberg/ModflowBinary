#==================================================================================================
# R:/ModflowBinary/P80headDiffProbabilities.R
#==================================================================================================
#==================================================================================================
# Beginning of P80 Head Difference evaluation for Probable Change in Stressed Acres
#
# Created by Kevin A. Rodberg - February 2019
#
# Purpose: Uses 2 matrices returned by P80headDifference.R,
#          inports csvfiles of wetland point locations, and probability calculation
#          data [zetaModels generated by ZetaCalcIntegrals.R].  
#          Creates cell by cell probability matrix of change in
#          wetland stress and calculates the probable change in acres
#          by wetland type (ridge or plain) from stressed to unstressed and
#          from unstressed to stressed.
#==================================================================================================
#--
#   package management:
#     provide automated means for first time use of script to automatically 
#	  install any new packages required for this code, with library calls 
#	  wrapped in a for loop.
#--
pkgChecker <- function(x){
  for( i in x ){
    if( ! require( i , character.only = TRUE ) ){
      install.packages( i , dependencies = TRUE )
      require( i , character.only = TRUE )
    }
  }
}

list.of.packages <-c( "data.table","devtools","utils","githubinstall",
                      "tcltk2","rModflow","future.apply","future","listenv",
                      "rasterVis","sp","maptools","rgeos","raster",
                      "ggplot2","RColorBrewer","tictoc","dplyr","polynom")

suppressWarnings(pkgChecker(list.of.packages))

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]

if ("rModflow" %in% new.packages) devtools::install_github("KevinRodberg/rModflow")
lapply(list.of.packages,require, character.only=TRUE)

options(warn=-1)
#--------------------------------------------------------------------------------------------------
# Provides GUI to choose model  
# - may not be needed any long in this code since its used in P80headDifference.R
#--------------------------------------------------------------------------------------------------
source ("//ad.sfwmd.gov/dfsroot/data/wsd/SUP/devel/source/R/ReusableFunctions/tclFuncs.R")
#source ("./ECFTX/tclFuncs.R")

plan(multiprocess)
ip=0
lowQuantile = 999
hiQuantile = -999
pltGrphs <- listenv(NULL)
probReturn <- listenv(NULL)

#==================================================================================================
tic('Process one layer')
#==================================================================================================

#--------------------------------------------------------------------------------------------------
#  Code provides option to not reread very large files
#  MFLay <- NULL is an easy way to force P80headDifference to start
#--------------------------------------------------------------------------------------------------
if (!exists('Layer1SIM2d') | !exists('MFLay')) {
  MFLay <- 1
  source ("//ad.sfwmd.gov/dfsroot/data/wsd/SUP/devel/source/R/ModflowBinary/P80headDifference.R")
} else { 
  if(!(utils::askYesNo(paste("Do you want to use layer ",MFLay, 
                             " from the previous binary heads data?"),
                       prompts = getOption("askYesNo", 
                                           gettext(c("Yes", "No", "Cancel")))))){
    if (MFLay == 1){ MFLay <- 3 } else { MFLay <-1 }
  source ("//ad.sfwmd.gov/dfsroot/data/wsd/SUP/devel/source/R/ModflowBinary/P80headDifference.R")
}
}
#==================================================================================================
tic('Create Differences from P80 Heads Layers')
#==================================================================================================
dataPath <- '//ad.sfwmd.gov/dfsroot/data/wsd/SUP/proj/CFWI_WetlandStress/Update2018'
DiffLay %<-% (qRC - qSIM) 

#Hint: If I subtract from this diffrence I get Stressed Wetlands Recovering
#DiffLay <- (qSIM - qRC) -1.5

#--------------------------------------------------------------------------------------------------
#   Calculate mean water level layers simultaneously
#--------------------------------------------------------------------------------------------------
avgRC %<-% future_apply (Layer1RC2d,MARGIN=c(1,2),FUN=mean,na.rm=T)
avgSIM %<-%future_apply (Layer1SIM2d,MARGIN=c(1,2),FUN=mean,na.rm=T)

#--------------------------------------------------------------------------------------------------
#   Calculate a mean difference water level layer
#--------------------------------------------------------------------------------------------------
HdDif <- avgRC-avgSIM

#==================================================================================================
# Fisnished Creating Differences from P80 Heads Layers
#==================================================================================================
toc()
#==================================================================================================
tic('GIS overhead')
#==================================================================================================
cat('Developing GIS data sets for raster plots \n')

#--------------------------------------------------------------------------------------------------
# NAD83 HARN StatePlane Florida East FIPS 0901 Feet
#--------------------------------------------------------------------------------------------------
HARNSP17ft  = CRS("+init=epsg:2881")
HARNUTM17Nm  = CRS("+init=epsg:3747")
latlongs = CRS("+proj=longlat +datum=WGS84")

#--------------------------------------------------------------------------------------------------
# Set up county boundry shapefile for overlay 
# on raster maps
#--------------------------------------------------------------------------------------------------
gClip <- function(shp, bb) {
  if (class(bb) == "matrix")
    b_poly <- as(extent(as.vector(t(bb))), "SpatialPolygons")
  else
    b_poly <- as(extent(bb), "SpatialPolygons")
  rgeos::gIntersection(shp, b_poly, byid = T)
}

WMDbnd.Path <- "//whqhpc01p/hpcc_shared/krodberg/NexRadTS"
WMDbnd.Shape <- "CntyBnds"

CFWIbnd.Path <-"//ad.sfwmd.gov/dfsroot/data/wsd/GIS/GISP_2012/DistrictAreaProj/CFWI/Data"
CFWIbnd.Shape <- "CFWI_Boundary"

physio.Path <-paste0("//ad.sfwmd.gov/dfsroot/data/wsd/GIS/GISP_2012/",
                     "References/FDEP/Richardson_Sept2012/PhysiograhicProvinces")
physio.shape <- "PHYSIOGRAPHIC_PROVINCES"

SomeLakes.Path <- paste0("//ad.sfwmd.gov/dfsroot/data/wsd/GIS/GISP_2012/DistrictAreaProj/",
                         "ECFT/Data/Waterbodies")
SomeLakes.shape <- "Lakecells_Dissolve"

WMDbnd %<-% rgdal::readOGR(dsn=WMDbnd.Path,layer=WMDbnd.Shape,verbose=FALSE)
CFWIbnd %<-% rgdal::readOGR(dsn=CFWIbnd.Path,layer=CFWIbnd.Shape,verbose=FALSE)
physiobnd %<-% rgdal::readOGR(dsn=physio.Path,layer=physio.shape,verbose=FALSE)
SomeLakes %<-% rgdal::readOGR(dsn=SomeLakes.Path,layer=SomeLakes.shape,verbose=FALSE)

WMDbnd <- sp::spTransform(WMDbnd,CRS=HARNSP17ft)
CFWIbnd <- sp::spTransform(CFWIbnd,CRS=HARNSP17ft)
physiobnd <- sp::spTransform(physiobnd,CRS=HARNSP17ft)
SomeLakes <- sp::spTransform(SomeLakes,CRS=HARNSP17ft)
#==================================================================================================
# Finished GIS overhead
#==================================================================================================
toc()
#==================================================================================================
tic('Develop rasters')
#==================================================================================================
#--------------------------------------------------------------------------------------------------
# calculate number of rows and columns
#--------------------------------------------------------------------------------------------------
res=MFmodel.Params[model,]$res
xmin=MFmodel.Params[model,]$xmin
ymin=MFmodel.Params[model,]$ymin
rasRows=MFmodel.Params[model,]$nrows
rasCols=MFmodel.Params[model,]$ncols
xmax=xmin+(res*rasCols)
ymax=ymin+(res*rasRows)

cellsize=c(res,res)
ras <- raster::raster(res=cellsize, xmn=xmin,xmx=xmax,ymn=ymin,ymx=ymax,crs=HARNSP17ft)
#--------------------------------------------------------------------------------------------------
# define raster and map extents using MFmodel data extents
#--------------------------------------------------------------------------------------------------
rasExt <- raster::extent(ras)
clpBnds2 <- gClip(WMDbnd, ras)

#--------------------------------------------------------------------------------------------------
# Create raster plot of the DiffMatrix
#   note: t() is used to transpose the array axis for plotting
#--------------------------------------------------------------------------------------------------
diffRas<-raster::raster(t(DiffLay[,]),rasExt[1:4], crs=HARNSP17ft)

diffRas <- raster::crop(diffRas, extent(buffer(CFWIbnd,width=10000)))
diffRas %<-% raster::mask(diffRas, CFWIbnd)

title = paste("Change in Head Layer ",MFLay,": \n",
              RCheadsFile, '\nminus\n',SIMheadsFile)

# basePath <- paste0("//ad.sfwmd.gov/dfsroot/data/wsd/SUP/proj/",
#                    "CFWI_WetlandStress/Update2018/Figs4StressAcresSWUCA40/")
# basePath <- paste0("//ad.sfwmd.gov/dfsroot/data/wsd/SUP/proj/",
#                    "CFWI_WetlandStress/Update2018/Figures4StressAcresSWUCA25/")
basePath <- paste0("//ad.sfwmd.gov/dfsroot/data/wsd/SUP/proj/",
                   "CFWI_WetlandStress/Update2018/Figures4StressAcresSWUCA30/")
filename = paste0('p80headDiffLay',MFLay,'.tif')
ip=ip+1
pltGrphs[[ip]] <- future({
  raster::writeRaster(diffRas, filename, format="GTiff", overwrite=TRUE)
})

lowQuantile = min(lowQuantile,quantile(DiffLay,probs=c(.03),na.rm=T),na.rm=T)
hiQuantile = max(hiQuantile,quantile(DiffLay,probs=c(.97),na.rm=T),na.rm=T)
my.at = c(quantile(DiffLay,probs=c(.00001),na.rm=T),
          -2.5,-2.0,-1.5,-1.25,-1.0,-.75,-.5,-.25,-.2,-.15,-.1,-.05,0.0,
          .05,.1,.15,.2,0.25,0.50,0.75,1.0,1.25,1.5,2.0,2.5,
          quantile(DiffLay,probs=c(.99999),na.rm=T))

Class1.Wetland.Info <- 
  read.csv(paste0(dataPath,"/Class 1 Wetland Info for Analysis ALLv1.csv"))
c1Wtl.pnts <-
  sp::SpatialPointsDataFrame(Class1.Wetland.Info[,11:12],Class1.Wetland.Info,
                         proj4string=latlongs)
c1Wtl.pnts <- sp::spTransform(c1Wtl.pnts,HARNSP17ft)

filename=paste0(basePath,"Lay",MFLay,"_P80HeadDifference.png")
WLTheme = rasterTheme(region = brewer.pal('BrBG', n = 9))
options(scipen=7)
myplot= (levelplot(diffRas,par.settings = WLTheme,at=my.at,main=title)+
           latticeExtra::layer(sp.points(c1Wtl.pnts, pch = 20,col = "black")) +
           latticeExtra::layer(sp.text(coordinates(c1Wtl.pnts),
                                       txt=c1Wtl.pnts$CFCA.EMT.ID,pos=1,cex=.5 )) +
           latticeExtra::layer(sp.polygons(clpBnds2, col='darkgray'))+
           latticeExtra::layer(sp.polygons(physiobnd, col='brown'))+
           latticeExtra::layer(sp.polygons(SomeLakes, col='gray'))+
           latticeExtra::layer(sp.polygons(CFWIbnd, col='red'))
)
trellis.device(device="png", filename=filename, width=4500,height=4500,
               units="px",res=300)
print(myplot)
dev.off()

#---
# Convert array layers to rasters
#---
qRCras %<-% raster::raster(t(qRC[,]),rasExt[1:4], crs=HARNSP17ft)
qSIMras %<-% raster::raster(t(qSIM[,]),rasExt[1:4], crs=HARNSP17ft)
RCras %<-% raster::raster(t(avgRC[,]),rasExt[1:4], crs=HARNSP17ft)
SIMras %<-% raster::raster(t(avgSIM[,]),rasExt[1:4], crs=HARNSP17ft)
HdDifras %<-% raster::raster(t(HdDif[,]),rasExt[1:4], crs=HARNSP17ft)

qRCras[qRCras > 900]<-NA
RCras[RCras > 900]<-NA
qSIMras[qSIMras> 900 ]<-NA
SIMras[SIMras> 900 ]<-NA

#---
#  Function to create maps as png and tif from rasters 
#---
plotTiffAndPng <- function(ras2Plot,rasName){
  ras2Plot[ras2Plot > 900] <- NA
  Rng = max(abs(quantile(ras2Plot,probs=c(.00001),na.rm=T)),
            abs(quantile(ras2Plot,probs=c(.99999),na.rm=T)))
  interval = Rng/10
  my.at = c(seq(-Rng,Rng,interval))
    filename = paste0(rasName,MFLay,'.tif')
  writeRaster(ras2Plot, paste0(basePath,filename), format="GTiff", overwrite=TRUE)
  filename = paste0(basePath,rasName,MFLay,'.png')
  title =paste0(rasName,MFLay)
  myplot= (levelplot(ras2Plot,par.settings = WLTheme,at=my.at, main = title)+
             latticeExtra::layer(sp.polygons(clpBnds2, col='darkgray'))+
             latticeExtra::layer(sp.polygons(physiobnd, col='brown'))+
             latticeExtra::layer(sp.polygons(SomeLakes, col='blue'))+
             latticeExtra::layer(sp.polygons(CFWIbnd, col='red')))
  trellis.device(device="png", filename=filename, width=3000,height=4500,units="px",res=300)
  print(myplot)
  dev.off()
}

ip=ip+1
pltGrphs[[ip]] <- future({plotTiffAndPng(HdDifras,'meanHeadDiffLay')})
ip=ip+1
pltGrphs[[ip]] <- future({plotTiffAndPng(SIMras,'meanSIMLay')})
ip=ip+1
pltGrphs[[ip]] <- future({plotTiffAndPng(RCras,'meanRCLay')})
ip=ip+1
pltGrphs[[ip]] <- future({plotTiffAndPng(qSIMras,'p80SIMLay')})
ip=ip+1
pltGrphs[[ip]] <- future({plotTiffAndPng(qRCras,'p80RCLay')})

#==================================================================================================
# Fisnished Developing rasters for GIS and map pngs
#==================================================================================================
toc()
#==================================================================================================
tic("Read Wetland datasets")
#==================================================================================================
#  Read Polynomial Coefficiencts for Zeta Calculations
#     and
#  wetlands points by class from GIS exports
#     and
#  eliminate unnecessary columns, rename fields for consistency, 
#  as well as fix Stressed column indicator to be consistent for 
#  Class 1 and 2
#====================================================================
# polys<-read.csv(paste0(dataPath,"/PolyCoeff2019.csv"))
SFact<-read.csv(paste0(dataPath,"/StressFactor.csv"))

# class1 %<-% read.csv(paste0(dataPath,"/WetlandsClass1_2019v2.csv"))
class1 %<-% read.csv(paste0(dataPath,"/WetlandsClass1_2019v2imperv.csv"))
# class2 %<-% read.csv(paste0(dataPath,"/WetlandsClass2_2019v3.csv"))
class2 %<-% read.csv(paste0(dataPath,"/WetlandsClass2_2019v3imperv.csv"))
# class3 %<-% read.csv(paste0(dataPath,"/WetlandsClass3_2019v2.csv"))
class3 %<-% read.csv(paste0(dataPath,"/WetlandsClass3_2019v2imperv.csv"))

class1<- merge(x=class1, 
               y=Class1.Wetland.Info[,c('CFCA.EMT.ID','Stress.Status.in.2018')],
               by.x = "CFCA_EMT_I", by.y = 'CFCA.EMT.ID')

class1Scale <- class1 %>% 
  group_by(CFCA_EMT_I) %>%
  summarize(sum(ACRES_COMB),mean(nlcd11))
class1Scale<-merge(class1Scale,Class1.Wetland.Info, by.x='CFCA_EMT_I' ,by.y='CFCA.EMT.ID')
write.csv(class1Scale,paste0(dataPath,'/class1FromR.csv'))

class2Scale <- class2 %>% 
  group_by(CFCA_ID) %>%
  summarize(sum(ACRES_COMB))
# temp <-unique(class2[,c(2,5,14,15,17,18,37)])
temp <-unique(class2[,c(4,7,16,17,19,20,37)])
class2Scale<-merge(class2Scale,temp, by.x='CFCA_ID' ,by.y='CFCA_ID')
write.csv(class2Scale,paste0(dataPath,'/class2FromR.csv'))

#NotNeeded <- c("OBJECTID","CFCA_EMT_1","PERCENT_AC","Shape_Length","Shape_Area")
NotNeeded <- c("OBJECTID")
class1[NotNeeded]<-NULL
setnames(class1, "CFCA_EMT_I", "CFCA_EMT_ID")
setnames(class1, "Wetland_Ty", "Wetland_Type")
setnames(class1, "Physiograp", "Phys")
setnames(class1, "Stress.Status.in.2018", "Stressed")
setnames(class1, "ACRES_COMB", "Acres")
setnames(class1, "nlcd11", "ImpervPercent")
class1$Imperv <-FALSE
class1[class1$ImpervPercent>10,]$Imperv <-TRUE

levels(class1$Stressed)[which(levels(class1$Stressed)=="Not Stressed")] <- "NO"
levels(class1$Stressed)[which(levels(class1$Stressed)=="Stressed")] <- "YES"

Needed <- c("CFCA_ID","ACRES_COMB","Ridge_or_P","SEQNUM","XCOORD_UTM" ,"YCOORD_UTM" ,"Stressed","nlcd11","SpecialInt")

class2 <- class2[,Needed]
setnames(class2, "CFCA_ID", "CFCA_EMT_ID")
setnames(class2, "ACRES_COMB", "Acres")
setnames(class2, "Ridge_or_P", "Phys")
setnames(class2, "nlcd11", "ImpervPercent")
class2$Imperv <-FALSE
class2[class2$ImpervPercent>10,]$Imperv <-TRUE

levels(class2$Phys)[which(levels(class2$Phys)=="Plains")] <- "Plain"

Needed<-c("SEQNUM_1","Hydroclass","EcoHydro_T","Wetland_Ty","Urban_Dens","SusceptGW",   
          "Class","XCOORD_UTM","YCOORD_UTM","ACRES_COMB","nlcd11","SpecialInt")

class3 <- class3[,Needed]
setnames(class3, "ACRES_COMB", "Acres")
setnames(class3, "Wetland_Ty", "Phys")
setnames(class3, "Urban_Dens", "Urban_Density")
setnames(class3, "SEQNUM_1", "SEQNUM")
setnames(class3, "nlcd11", "ImpervPercent")
class3$Imperv <-FALSE
class3[class3$ImpervPercent>10,]$Imperv <-TRUE

vars4AreaZ <- c("Zus","Zsu")
class1[vars4AreaZ]<- NA
class2[vars4AreaZ]<- NA
class3[vars4AreaZ]<- NA

vars4SF <- c("SFsu","SFus")
class1[vars4SF]<-1.0
class2[vars4SF]<-1.0
class3[vars4SF]<-NA

#---------------------------------------------------------------------------------
# Wetland Weighting Factors:
# The reason for the weighting factors is that the Class 1 & Class 2 wetlands have
# been physically inspected. 
#
# 1. Wetlands that are of the wrong hydrobiologic type have been excluded 
# 2. "Significantly Hydrologically Altered" (SHA) Wetlands have been excluded 
# 3. Wetland condition is known to be either stressed or unstressed.
# 
# Without physical inspections of the Class 3 wetlands to supply that information,
# the total GIS wetland area is assigned a probability factor to represent the 
# likelihood of the wetland being one for which either the Zu-s or Zs-u equation is 
# appropriate.  
#
# These probability factors were derived by comparing the Class 2 wetlands to the 
# corresponding total wetland coverages.  
#
# First multiply by the Dissimilarity Factor and the SHA Factor - 
#     this reduces the total acreage by an amount that corrects for the likelihood 
#     of GIS wetland area that is the "wrong" type of wetland, or that is SHA.  
#
# Second Multiply that product again - 
# once by the fraction of the surviving wetlands that are initially unstressed 
#   to produce the SFu-s total correction factor, 
#     and once by the fraction of the surviving wetlands that are initially  
#       stressed to produce the SFs-u total correction factor.
#
#     TotCorrFact_us = DisFac*SHA_Fact*SFus
#     TotCorrFact_su = DisFac*SHA_Fact*SFsu
#---------------------------------------------------------------------------------
#  Wetland 	Urban 	Dissimilar 	SHA 	   Stress   Stress  Correction  Correction 
#  Type     Density   Factor    Factor   Factor   Factor    Factor       Factor
#                                       (u to s) (s to u)    (u-s)        (s-u)
#---------------------------------------------------------------------------------
#  Plain     low      0.694     0.820      0.824    0.176    0.469        0.100
#  Plain  Mod & High  0.616     0.581      0.824    0.176    0.295        0.063
#  Ridge     All      0.671     1.000      0.581    0.419    0.390        0.281
#---------------------------------------------------------------------------------
class3[class3$Phys=='Plain',]$SFus = SFact[SFact$Wetland.Type=='Plain' &
                                             SFact$Urban.Density == 'low',]$Sfus

class3[class3$Phys=='Plain',]$SFsu = SFact[SFact$Wetland.Type=='Plain' &
                                             SFact$Urban.Density == 'low',]$Sfsu

class3[class3$Phys=='Plain' &  (class3$Urban_Density=='Moderate' |
                                  class3$Urban_Density=='High') ,]$SFus =
  SFact[SFact$Wetland.Type=='Plain' & SFact$Urban.Density == 'Mod & High',]$Sfus

class3[class3$Phys=='Plain' &  (class3$Urban_Density=='Moderate' |
                                  class3$Urban_Density=='High') ,]$SFsu = 
  SFact[SFact$Wetland.Type=='Plain' & SFact$Urban.Density == 'Mod & High',]$Sfsu

class3[class3$Phys=='Ridge',]$SFus = SFact[SFact$Wetland.Type=='Ridge',]$Sfus
class3[class3$Phys=='Ridge',]$SFsu = SFact[SFact$Wetland.Type=='Ridge',]$Sfsu
#==================================================================================================
# Finished Reading Wetland datasets
#==================================================================================================
toc()
#==================================================================================================
tic('Calculate probable stress for wetlands')
#==================================================================================================
#--------------------------------------------------------------------------------------------------
#  Create template dataframe for Stats
#--------------------------------------------------------------------------------------------------
if (!exists('Stats')){
  Layer <- c(rep(1,24),rep(3,24))
  Class <- rep(c(rep(1,8),rep(2,8),rep(3,8)),2)
  Stress <- rep(rep(c(rep('Stressed',4),rep('Unstressed',4)),3),2)
  Phys<- rep(rep(rep(c(rep('Plain',2),rep('Ridge',2)),2),3),2)
  SpecialInt<-rep(rep(rep(rep(c("SWUCA", "non-SWUCA"),2),2),3),2)
  Stats<-data.frame(Layer,Class,Stress,Phys,SpecialInt,stringsAsFactors=FALSE)
  Stats<-unique(Stats)
  statColumns<-c('Total','Initial','Delta','Relative','Aquifer','exclude')
  Stats[statColumns]<-NA
}

WetType = c("Plain" ,"Ridge")

WetCond<-c('YES', 'NO')
ZetaCond<-c('Stressed', 'Unstressed')

#--------------------------------------------------------------------------------------------------
#  Read zeta Models created by ZetaCalcIntegrals.R rather than polyCoeff.csv 
#--------------------------------------------------------------------------------------------------
#workdir= "Y:/proj/CFWI_WetlandStress/Update2018"
workdir= "//ad.sfwmd.gov/dfsroot/data/wsd/SUP/proj/CFWI_WetlandStress/Update2018"
zetaModels=readRDS( paste0(workdir,"zetaModels.RDS"))

#--------------------------------------------------------------------------------------------------
#  Function to create probLay matrix of probabilities 
#--------------------------------------------------------------------------------------------------
getProbLay<- function(DiffLay,NegModel,PosModel){
  probLay<-DiffLay
  newdata <- data.frame (delta = as.vector(DiffLay[DiffLay<0]))
  probtemp<- predict(NegModel,newdata=newdata)
  probLay[DiffLay<0]<-probtemp
  newdata <- data.frame (delta = as.vector(probLay[DiffLay>=0]))
  probtemp<- predict(PosModel,newdata=newdata)
  probLay[DiffLay>=0]<-probtemp
  return(probLay)
}
ip=0
ipl=0
for (c in ZetaCond){
  p<- NULL
  probLay<- (DiffLay*0)
  for (t in WetType) {
    cc = 'NO'
    zetaName = 'us'
    probTitle <- 'Unstressed to Stressed'
    if(c == 'Stressed'){
      cc = 'YES'
      zetaName = 'su'
      probTitle <- 'Stressed to Unstressed'
      }
    ipl=ipl+1
    if (t == 'Ridge' & c == 'Unstressed'){
      probLay<-getProbLay(DiffLay,zetaModels$ZRPu_sNeg,zetaModels$ZRPu_sPos)
    } else if (t == 'Ridge' & c == 'Stressed'){
      probLay<-getProbLay(DiffLay,zetaModels$ZRPs_uNeg,zetaModels$ZRPs_uPos)
    } else if (t == 'Plain' & c == 'Unstressed'){
      probLay<-getProbLay(DiffLay,zetaModels$ZPPu_sNeg,zetaModels$ZPPu_sPos)
    }else if (t == 'Plain' & c == 'Stressed'){
      probLay<-getProbLay(DiffLay,zetaModels$ZPPs_uNeg,zetaModels$ZPPs_uPos)
    } else {
      cat('Something goofed up!\n')
      cat(paste(c, t))
    }
    probLay[probLay<0] <- 0
    probLay[probLay>1] <- 1
    #--------------------------------------------------------------------------
    #  probLay matrix of probabilities is intersected w/wetlands pnts by SEQNUM
    #--------------------------------------------------------------------------
    zetaCol <-match(paste0('Z',zetaName),names(class1))
    class1[class1$Phys == t & class1$Stressed ==cc,zetaCol] <-
      round(probLay[class1[class1$Phys == t & class1$Stressed ==cc,]$SEQNUM],8)
    
    zetaCol <-match(paste0('Z',zetaName),names(class2))
    class2[class2$Phys == t & class2$Stressed ==cc,zetaCol] <-
      round(probLay[class2[class2$Phys == t & class2$Stressed ==cc,]$SEQNUM],8)
    
    # Initial stress condition is not know for class 3
    zetaCol <-match(paste0('Z',zetaName),names(class3))
    class3[class3$Phys == t,zetaCol] <-
      round(probLay[class3[class3$Phys == t,]$SEQNUM],8)
    #--------------------------------------------------------------------------
    # Crop raster data by extent of CFWI bndry
    #--------------------------------------------------------------------------
    
    probRas<-raster::raster(t(probLay[,]),rasExt[1:4], crs=HARNSP17ft)    
    yourTheme = rasterTheme(region = brewer.pal('YlOrRd', n = 9))
    CFWIprobs <- raster::crop(probRas, extent(buffer(CFWIbnd,width=10000)))
    CFWIprobs <- raster::mask(CFWIprobs, CFWIbnd)
    ip=ip+1
    pltGrphs[[ip]] <- future({
      plotTiffAndPng(CFWIprobs,paste('CFWIprob',t,probTitle)) 
    })
     
  }
}
#--------------------------------------------------------------------------
#  Class 1, 2, & 3 wetland probable change in area is calculated as
#   Stressed becoming unstressed:
#     AreaXZsu = Acres * SFsu * probs
#
#   Unstressed becoming stressed:
#     AreaXZus = Acres * SFus * probs
#--------------------------------------------------------------------------
class1 <- class1 %>% mutate(AreaXZsu = Acres*SFsu*Zsu)
class1 <- class1 %>% mutate(AreaXZus = Acres*SFus*Zus)

class2 <- class2 %>% mutate(AreaXZsu = Acres*SFsu*Zsu)
class2 <- class2 %>% mutate(AreaXZus = Acres*SFus*Zus)

class3 <- class3 %>% mutate(AreaXZsu = Acres*SFsu*Zsu)
class3 <- class3 %>% mutate(AreaXZus = Acres*SFus*Zus)
#==================================================================================================
# Fisnised Calculating probable stress for wetlands
#==================================================================================================
toc()
#==================================================================================================
tic("Creating maps")
#==================================================================================================
class1.pnts <- sp::SpatialPointsDataFrame(coords = class1[, c("XCOORD_UTM", "YCOORD_UTM")], 
                                           data = class1,proj4string = HARNUTM17Nm)
c1.pnts<-sp::spTransform(class1.pnts,HARNSP17ft)

class2.pnts <- sp::SpatialPointsDataFrame(coords = class2[, c("XCOORD_UTM", "YCOORD_UTM")], 
                                          data = class2,proj4string = HARNUTM17Nm)
c2.pnts<-sp::spTransform(class2.pnts,HARNSP17ft)

class3.pnts <-sp::SpatialPointsDataFrame(coords = class3[, c("XCOORD_UTM", "YCOORD_UTM")],
                                         data = class3,proj4string = HARNUTM17Nm)
c3.pnts<-sp::spTransform(class3.pnts,HARNSP17ft)

probRas<-raster::raster(t(probLay[,]),rasExt[1:4], crs=HARNSP17ft)
yourTheme = rasterTheme(region = brewer.pal('YlOrRd', n = 9))

#--------------------------------------------------------------------------
# Crop raster data by extent of CFWI bndry
#--------------------------------------------------------------------------
CFWIprobs <- raster::crop(probRas, extent(buffer(CFWIbnd,width=10000)))
CFWIprobs <- raster::mask(CFWIprobs, CFWIbnd)

updateStatsDelta<- function(Stats,MFLay,t,c,class,special,source) {
  # cat(paste(Stats[Stats$Layer == MFLay &
  #                   Stats$Phys ==t &
  #                   Stats$Stress ==c &
  #                   Stats$Class==class,]$Delta,
  #           MFLay,t,c,class,sum(source,na.rm=T),'\n'))
  
  Stats[Stats$Layer == MFLay & 
          Stats$Phys ==t & 
          Stats$Stress ==c & 
          Stats$SpecialInt == special &
          Stats$Class==class,]$Delta <- round(sum(source,na.rm=T),2)
  return(Stats)
}
updateStatsInitial<- function(Stats,MFLay,t,c,class,special,Acres) {
  # cat(paste(Stats[Stats$Layer == MFLay & 
  #                   Stats$Phys ==t & 
  #                   Stats$Stress ==c & 
  #                   Stats$Class==class,]$Initial,
  #           MFLay,t,c,class,sum(Acres,na.rm=T),'\n'))
  Stats[Stats$Layer == MFLay & 
          Stats$Phys ==t & 
          Stats$Stress ==c & 
          Stats$SpecialInt == special &
          Stats$Class==class,]$Initial <- round(sum(Acres,na.rm=T),2)
  return(Stats)
}

ip=0
deltas = stack()
if (MFLay == 1){
  deltasByPhys = stack()
}

InOrOut = c("SWUCA", "non-SWUCA")

for (i in InOrOut) {
  for (t in WetType) {
    ttlWetAcres = 0
    for (c in ZetaCond){
      if (c == 'Stressed') {
        cc <-'YES'
        c1sub <-c1.pnts[c1.pnts$Phys==t & c1.pnts$Stressed==cc & c1.pnts$SpecialInt == i,c('Phys','AreaXZsu')]
        c2sub <-c2.pnts[c2.pnts$Phys==t & c2.pnts$Stressed==cc& c2.pnts$SpecialInt == i,c('Phys','AreaXZsu')]
        c3sub <-c3.pnts[c3.pnts$Phys==t & c3.pnts$SpecialInt == i,c('Phys','AreaXZsu')]
        c123sub<-rbind(c1sub,c2sub)
        c123sub<-rbind(c123sub,c3sub)
        if (length(c1sub$AreaXZsu) > 0) {
          Stats<-updateStatsDelta(Stats,MFLay,t,c,1,i,c1sub$AreaXZsu)
          Acres =   c1.pnts[c1.pnts$Phys ==t & c1.pnts$Stressed ==cc & c1.pnts$SpecialInt == i,]$Acres
          Stats<-updateStatsInitial(Stats,MFLay,t,c,1,i,Acres)
        }
        if (length(c2sub$AreaXZsu) > 0) {
          Stats<-updateStatsDelta(Stats,MFLay,t,c,2,i,c2sub$AreaXZsu)
          Acres =   c2.pnts[c2.pnts$Phys ==t & c2.pnts$Stressed ==cc & c2.pnts$SpecialInt == i,]$Acres
          Stats<-updateStatsInitial(Stats,MFLay,t,c,2,i,Acres)
        }
        if (length(c3sub$AreaXZsu) > 0) {
          Stats<-updateStatsDelta(Stats,MFLay,t,c,3,i,c3sub$AreaXZsu)
          Acres =  c3.pnts[c3.pnts$Phys ==t & c3.pnts$SpecialInt == i,]$Acres * 
            c3.pnts[c3.pnts$Phys ==t & c3.pnts$SpecialInt == i,]$SFsu
          Stats<-updateStatsInitial(Stats,MFLay,t,c,3,i,Acres)
        }
      } else {
        cc<-'NO'
        c1sub <-c1.pnts[c1.pnts$Phys==t & c1.pnts$Stressed==cc & c1.pnts$SpecialInt == i,c('Phys','AreaXZus')]
        c2sub <-c2.pnts[c2.pnts$Phys==t & c2.pnts$Stressed==cc & c2.pnts$SpecialInt == i,c('Phys','AreaXZus')]
        c3sub <-c3.pnts[c3.pnts$Phys==t  & c3.pnts$SpecialInt == i,c('Phys','AreaXZus')]
        
        if( length(c1sub)+length(c2sub) >0){
          c123sub<-rbind(c1sub,c2sub)
          c123sub<-rbind(c123sub,c3sub)
        } else
        {
          c123sub <- c3sub
        }

        if (length(c1sub$AreaXZus) > 0) {
          Stats<-updateStatsDelta(Stats,MFLay,t,c,1,i,c1sub$AreaXZus)
          Acres =   c1.pnts[c1.pnts$Phys ==t & c1.pnts$Stressed ==cc & c1.pnts$SpecialInt == i,]$Acres
          Stats<-updateStatsInitial(Stats,MFLay,t,c,1,i,Acres)
        }
        if (length(c2sub$AreaXZus) > 0) {
          Stats<-updateStatsDelta(Stats,MFLay,t,c,2,i,c2sub$AreaXZus)
          Acres =   c2.pnts[c2.pnts$Phys ==t & c2.pnts$Stressed ==cc & c2.pnts$SpecialInt == i,]$Acres
          Stats<-updateStatsInitial(Stats,MFLay,t,c,2,i,Acres)
        }
        if (length(c3sub$AreaXZus) > 0) {
          Stats<-updateStatsDelta(Stats,MFLay,t,c,3,i,c3sub$AreaXZus)
          Acres =  c3.pnts[c3.pnts$Phys ==t & c3.pnts$SpecialInt == i,]$Acres * 
            c3.pnts[c3.pnts$Phys ==t & c3.pnts$SpecialInt == i,]$SFus
          Stats<-updateStatsInitial(Stats,MFLay,t,c,3,i,Acres)
        }
      }  
      
      if (MFLay == 3){
        Stats[Stats$Layer == 3 & Stats$Phys =='Plain' ,]$Delta<- 0
        Stats[Stats$Layer == 3 & Stats$Phys =='Plain' ,]$Initial<- 0
      }
      #
      # Calc total inital acres of each type and class
      #
      
      
      c1.delta<-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==1 & Stats$SpecialInt==i,]$Delta
      c2.delta<-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==2 & Stats$SpecialInt==i,]$Delta
      c3.delta<-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==3 & Stats$SpecialInt==i,]$Delta
      
      c1.initial <-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==1 & Stats$SpecialInt==i,]$Initial
      c2.initial <-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==2 & Stats$SpecialInt==i,]$Initial
      c3.initial <-Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Stress ==c & Stats$Class==3 & Stats$SpecialInt==i,]$Initial
      
      tabStats = paste('c1=',round(c1.delta,2),'c2=',round(c2.delta,2),'c3=',round(c3.delta,2),'\n',
                       round(sum(c1.delta,c2.delta,c3.delta),2),'/',
                       round(sum(c1.initial,c2.initial,c3.initial),2),'=', 
                       round(100*sum(c1.delta,c2.delta,c3.delta)/
                               sum(c1.initial,c2.initial,c3.initial),2),'% of',t,'Wetlands')
      if (c == ZetaCond[2]){
        title = paste0('Layer ',MFLay,' ',c,' ',t,' to ', ZetaCond[1], '\n',tabStats)
        filename=paste(basePath,paste0('Lay',MFLay,t,'-',c,'_to_',ZetaCond[1]),".png",sep="")
        acre.At = c(0,.5,1,2.5,5,7.5,10,max(c123sub$AreaXZus))
        deltaArea<- rasterize(c123sub,CFWIprobs,c123sub$AreaXZus)
      #  cat(paste("Max acres for ", c, t, max(deltaArea@data@values,na.rm=T),'\n'))
        tiffilename=paste(basePath,paste0('Lay',MFLay,t,'-',c,'_to_',ZetaCond[1]),".tif",sep="")
      }else {
        title = paste0('Layer ',MFLay,' ',c,' ',t,' to ', ZetaCond[2], '\n',tabStats)
        filename=paste(basePath,paste0('Lay',MFLay,t,'-',c,'_to_',ZetaCond[2]),".png",sep="")
        acre.At = c(0,.5,1,2.5,5,7.5,10,max(c123sub$AreaXZsu,na.rm=TRUE))
        deltaArea<- rasterize(c123sub,CFWIprobs,c123sub$AreaXZsu)
      #  cat(paste("Max acres for ", c, t, max(deltaArea@data@values,na.rm=T),'\n'))
        tiffilename=paste(basePath,paste0('Lay',MFLay,t,'-',c,'_to_',ZetaCond[2]),".tif",sep="")
      }
      if (MFLay == 1 & t == "Plain" ){
        cat(paste('Adding Lay ',MFLay,' ',t,' to deltasByPhys stack \n'))
        deltasByPhys <- stack(deltasByPhys,deltaArea)
        cat(paste('Plains Lay1 step for deltasByPhys names After:', paste( unlist(names(deltasByPhys)), collapse=' ') ,'\n'))
      }
      if (MFLay == 3 & t == "Ridge" ){
        cat(paste('Adding Lay ',MFLay,' ',t,' to deltasByPhys stack \n'))
        deltasByPhys <- stack(deltasByPhys,deltaArea)
        cat(paste('Ridge Lay3 step for deltasByPhys names After:', paste( unlist(names(deltasByPhys)), collapse=' ') ,'\n'))
      }
      deltaArea[deltaArea==0]<-NA
      if(!(MFLay ==3 & t == 'Plain')){
        if (cc=='NO'){
          yourTheme = rasterTheme(region = brewer.pal('YlOrRd', n = 9))
        } else {
          yourTheme = rasterTheme(region = brewer.pal('YlGn', n = 9))
          
        }
        
        ip=ip+1
        cat(paste('Adding Lay ',MFLay,' ',t,' to deltas stack \n'))
        deltas <- stack(deltas,deltaArea)                                                                
        pltGrphs[[ip]] <- future({
          myplot= (levelplot(deltaArea,par.settings = yourTheme,at=acre.At, main = title)+
                     latticeExtra::layer(sp.polygons(clpBnds2, col='darkgray'))+
                     latticeExtra::layer(sp.polygons(physiobnd, col='brown'))+
                     latticeExtra::layer(sp.polygons(SomeLakes, col='blue'))+
                     latticeExtra::layer(sp.polygons(CFWIbnd, col='red')))
          trellis.device(device="png", filename=filename, width=3000,height=4500,units="px",res=300)
          print(myplot)
          dev.off()
        })
        ip=ip+1
        pltGrphs[[ip]] <- future({
          raster::writeRaster(deltaArea, tiffilename, format="GTiff", overwrite=TRUE)
        })
      }
      Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Class==1 & Stats$SpecialInt==i,]$Total<-
        sum(Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Class==1 & Stats$SpecialInt==i,]$Initial,na.rm=T)
      Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Class==2 & Stats$SpecialInt==i,]$Total<-
        sum(Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Class==2 & Stats$SpecialInt==i,]$Initial,na.rm=T)
      Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Class==3 & Stats$SpecialInt==i,]$Total<-
        sum(Stats[Stats$Layer == MFLay & Stats$Phys ==t & Stats$Class==3 & Stats$SpecialInt==i,]$Initial,na.rm=T)
    }
  }
}
if (MFLay == 1){
  names(deltas)<- c('Plain_StoU_SWUCA','Plain_UtoS_SWUCA','Ridge_StoU_SWUCA','Ridge_UtoS_SWUCA',
                    'Plain_StoU_NonSWUCA','Plain_UtoS_NonSWUCA','Ridge_StoU_NonSWUCA','Ridge_UtoS_NonSWUCA')
  cat(paste('Before:', paste( unlist(names(deltasByPhys)), collapse=' ') ,'\n'))
  names(deltasByPhys)<- c('Plain_StoU_SWUCA','Plain_UtoS_SWUCA','Plain_StoU_NonSWUCA','Plain_UtoS_NonSWUCA')
  cat(paste('After:', paste( unlist(names(deltasByPhys)), collapse=' ') ,'\n'))
  cat(paste('Switching sign on Stressed to Unstressed Plain','\n'))
  deltas$Plain_StoU_SWUCA <- deltas$Plain_StoU_SWUCA*(-1.0)
  deltas$Plain_StoU_NonSWUCA <- deltas$Plain_StoU_NonSWUCA*(-1.0)
  deltasByPhys$Plain_StoU_SWUCA <- deltasByPhys$Plain_StoU_SWUCA*(-1.0)
  deltasByPhys$Plain_StoU_NonSWUCA <- deltasByPhys$Plain_StoU_NonSWUCA*(-1.0)
} else {
  names(deltas)<- c('Ridge_StoU_SWUCA','Ridge_UtoS_SWUCA','Ridge_StoU_NonSWUCA','Ridge_UtoS_NonSWUCA')
  
  cat(paste(deltas@layers[[1]]@data@max, deltas@layers[[2]]@data@max,'\n'))
  cat(paste(deltasByPhys@layers[[1]]@data@max, deltasByPhys@layers[[2]]@data@max,'\n'))
  cat(paste('Before Stack:', paste( unlist(names(deltasByPhys)), collapse=' ') ,'\n'))
  
  # deltasByPhys<-stack(deltasByPhys,deltas)
  cat(paste(deltasByPhys@layers[[1]]@data@max, deltasByPhys@layers[[2]]@data@max, 
            deltasByPhys@layers[[3]]@data@max, deltasByPhys@layers[[4]]@data@max,'\n'))
  
  cat(paste('deltasByPhys names Before:', paste( unlist(names(deltasByPhys)), collapse=' ') ,'\n'))
  names(deltasByPhys)<- c('Plain_StoU_SWUCA','Plain_UtoS_SWUCA','Ridge_StoU_SWUCA','Ridge_UtoS_SWUCA',
                          'Plain_StoU_NonSWUCA','Plain_UtoS_NonSWUCA','Ridge_StoU_NonSWUCA','Ridge_UtoS_NonSWUCA')
  cat(paste('deltasByPhys names After:', paste( unlist(names(deltasByPhys)), collapse=' ') ,'\n'))
  
}
cat(paste('Switching sign on Stressed to Unstressed Ridge','\n'))
deltas$Ridge_StoU_SWUCA <- deltas$Ridge_StoU_SWUCA*(-1.0)
deltas$Ridge_StoU_NonSWUCA <- deltas$Ridge_StoU_NonSWUCA*(-1.0)

# Layer 1 ridges aren't saved to this dataframe for final tiff
if (MFLay == 3){
  deltasByPhys$Ridge_StoU_SWUCA <- deltasByPhys$Ridge_StoU_SWUCA*(-1.0)
  deltasByPhys$Ridge_StoU_NonSWUCA <- deltasByPhys$Ridge_StoU_NonSWUCA*(-1.0)
}

index<-names(deltas)
FinalNetStress <- raster::stackApply(deltas,1,fun=base::sum,na.rm=TRUE)
tiffilename=paste0(basePath,paste0('Lay',MFLay,"_NetStress.tif",sep=""))

# export tiff with Layer 1 Plain and layer 3 Ridge stress Acres
FinalNetStress2 <- raster::stackApply(deltasByPhys,1,fun=base::sum,na.rm=TRUE)
tiffilename2=paste0(basePath,paste0('Lay',MFLay,"_NetStress2.tif",sep=""))

ip=ip+1

# extreme = max(abs(maxValue(FinalNetStress)), abs(minValue(FinalNetStress)))
filename=paste0(basePath,paste0('Lay',MFLay,"_NetStress.png",sep=""))
title = paste0('Lay',MFLay,'_NetStress')
if (lowQuantile <0){
  ramp<-c(seq(lowQuantile, -.01, length=5), seq(0.01, hiQuantile, length=5))
  yourTheme = rasterTheme(region = c(colorRampPalette(c("seagreen", "white"))(5),
                                     colorRampPalette(c("white", "firebrick"))(5)))
}else {
  ramp<-seq(-1, hiQuantile, length=10)
  yourTheme = rasterTheme(region =colorRampPalette(c("white", "firebrick"))(11))
}
pltGrphs[[ip]] <- future({
  myplot= (levelplot(FinalNetStress,par.settings = yourTheme,at=ramp, main = title)+
             latticeExtra::layer(sp.polygons(clpBnds2, col='darkgray'))+
             latticeExtra::layer(sp.polygons(SomeLakes, col='blue'))+
             latticeExtra::layer(sp.polygons(CFWIbnd, col='red')))
  trellis.device(device="png", filename=filename, width=3000,height=4500,units="px",res=300)
  print(myplot)
  dev.off()
})
pltGrphs[[ip]] <- future({
  raster::writeRaster(FinalNetStress, tiffilename, format="GTiff", overwrite=TRUE)
})
pltGrphs[[ip]] <- future({
  raster::writeRaster(FinalNetStress2, tiffilename2, format="GTiff", overwrite=TRUE)
})

toc()
#==================================================================================================
# Finished Creating maps
#==================================================================================================
Stats[Stats$Layer==1,]$Aquifer <- 'Surficial'
Stats[Stats$Layer==3,]$Aquifer <- 'Upper Floridan'
Stats[Stats$Stress=="Stressed",]$Relative <- Stats[Stats$Stress=="Stressed",]$Delta*(-1.0)
Stats[Stats$Stress=="Unstressed",]$Relative <- Stats[Stats$Stress=="Unstressed",]$Delta
Stats$exclude = FALSE
# Stats[Stats$Layer==1 & Stats$Phys =="Ridge",]$exclude = TRUE
Stats[Stats$Layer==3 & Stats$Phys =="Plain",]$exclude = TRUE

write.csv(Stats,paste0(basePath,'WetlandStressStats_SWUCA.csv'))
#==================================================================================================
# Create Bar Charts from Wetland Stats
#==================================================================================================

colours <- c("red", "orange", "blue", "yellow", "green")
longStats<-melt(Stats,id.vars=1:5)
longStats<-within(longStats, Class <- factor(Class))
longStats<-within(longStats, variable <- factor(variable))
longStats$variable <- factor(longStats$variable,levels = c("Total","Initial","Delta","Relative","Aquifer","exclude" ))
longStats$value <- as.numeric(longStats$value)
pieces<-unlist(strsplit(RCheadsFile,"[\\\\]|[^[:print:]]"))
RCtitle <- pieces[length(pieces)-1]
pieces<-unlist(strsplit(SIMheadsFile,"[\\\\]|[^[:print:]]"))
SIMtitle <- pieces[length(pieces)-1]
L = MFLay
longStats<- longStats[order(longStats$Layer,longStats$SpecialInt, longStats$Class,longStats$Phys,longStats$Stress, longStats$variable),]
ggplot(longStats[longStats$variable %in% c('Delta') & longStats$Layer == L,], 
              aes(x = paste(SpecialInt,variable,Phys,Stress), y = value, 
           fill = Class)) +
  geom_bar(stat = 'identity') +
  xlab("Initial Condition") +
  ylab("Acres of Change") +theme(axis.text.x = element_text(angle = 90, hjust = 1))
  ggtitle(paste0("Layer",L,'\n',RCtitle,' minus ',SIMtitle))
plotfile =paste0(basePath,'Lay',L,'Barchart.png')
ggsave(plotfile,width = 10,height = 7.5,units = "in",dpi = 300,device = "png")


#==================================================================================================
toc()

